rem Asalto y castigo
rem Para QL, en SuperBASIC
let version$="00-20110422"

rem Copyright (C) 2011 Marcos Cruz (programandala.net)
rem Licencia: http://programandala.net/licencia

rem Versión original para ZX Spectrum, CPC y Blassic:
rem Copyright (C) 2009 Baltasar el Arquero
rem http://caad.es/baltasarq/

rem --------------------------------------------
rem Notas:

rem Este fichero usa codificación estándar ISO 8859-1,
rem **no el juego de caracteres propio de QL**.

rem Este programa utiliza varios comandos y funciones
rem de dos extensiones de SuperBASIC:

rem De "MegaToolkit", (C) 1992 Michael A. Crowe:
rem   true,false,here,char_w,char_x,pos_x,pos_y,lnum
rem De "DIY Toolkit", (C) Simon N. Goodwin:
rem   minimum,inarray%
rem De "Display toolkit", (C) Dilwyn Jones:
rem   flim_w,flim_h,flim_x,flim_y,dmode

rem --------------------------------------------
rem Main

main

defproc main

  first_time_init
  rep game
    credits
    game_init
    end_of_scene
    intro
    action_look
    rep your_turn
      plot
      command
      if start_over:exit your_turn
    endrep your_turn
  endrep game

enddef

rem --------------------------------------------
rem Argumento
rem Plot

defproc plot

  rem Comprueba las condiciones de la trama
  rem y actúa en consecuencia.

  if current_location=8 and location_exit(8,north)

    let location_exit(8,north)=false
    let saxons_follow=1
    narrate "Una partida sajona aparece por el este. Para cuando te vuelves al norte, ya no te queda ninguna duda: era una trampa."
    short_pause
    narrate "En el estrecho paso es posible resistir, aunque por desgracia sus efectivos son muy superiores a los tuyos.":rem "efectivos"?!!!
    end_of_scene 
    clear_screen
    narrate "Tus oficiales te conminan a huir."
    speak "Capturando a un general britano, ganan doblemente."
    narrate "Sabes que es cierto, y te duele."

    ret

  endif

  if saxons_follow and current_location<12
    let saxons_follow=saxons_follow+1
    narrate "No sabes cuánto tiempo te queda..."
    if saxons_follow>10 
      narrate "Los sajones te capturan. Su general, sonriendo ampliamente, dice:"
      speak "Bien, bien... Del gran Ulfius podremos sacar una buena ventaja."
      end_of_scene
      clear_screen
      action_end
    endif
    ret
  endif

  if current_location<10 and not location_exit(8,north)
    narrate "Tus hombres luchan con denuedo contra los sajones."
    ret
  endif

  if current_location>19 and (not is_it_accessible(the_torch) or not lit_the_torch)
    rem por qué >19?!!!
    narrate "Ante la reinante e intimidante oscuridad, retrocedes a donde puedes ver."
    short_pause
    let current_location=17
    action_look
    ret
  endif

  if current_location=51
    narrate "Agotado, das parte en el castillo de tu llegada y de lo que ha pasado."
    short_pause
    narrate "Pides audiencia al rey, Uther Pendragón."
    end_of_scene
    clear_screen
    speak "El rey, te indica el valido, ha ordenado que no se le moleste, pues sufre una amarga tristeza."
    short_pause
    narrate "No puedes entenderlo. El rey, tu amigo."
    short_pause
    narrate "Agotado, decepcionado, apesadumbrado, decides ir a dormir a tu casa. Es lo poco que puedes hacer."
    short_pause
    narrate "Te has ganado un buen descanso."
    end_of_scene
    clear_screen
    action_end
  endif

enddef

defproc location_plot

  rem Comprueba las condiciones de la trama
  rem relacionadas con el nuevo escenario
  rem y actúa en consecuencia.

  sel on current_location
    =11,38,44
      let location(the_lake)=current_location
    =1 to 9
      if location_exit(8,north):narrate "Tus hombres siguen tus pasos."
    =16
      narrate "En la distancia, por entre los resquicios de las rocas, y allende el canal de agua, los sajones tratan de buscar la salida que encontraste por casualidad."
    =31
      if location_exit(31,north)
        narrate "Las rocas yacen desmoronadas a lo largo del pasaje."
      else
        narrate "Las rocas bloquean el camino."
      endif
    =28
      let location_exit(28,east)=false
  endsel

  if not is_it_vanished(ambrosio) and can_be_taken(the_key) and (current_location=46 or ambrosio_follows)
    let location(ambrosio)=current_location
    narrate "Tu benefactor te sigue, esperanzado."
  endif

enddef

defproc rocks_and_log

  rem Acción de usar el tronco con las rocas.

  if hacked_the_log
    narrate "Haciendo palanca, consigues desencajar una, y el resto caen por su propio peso."
    do_vanish the_rocks
    let location_exit(31,north)=32
  else
    narrate "Lo intentas con el tronco, pero la punta es demasiado gruesa, y no penetra entre los resquicios de las rocas."
  endif

enddef

defproc open_the_door

  rem Acción de abrir la puerta.

  narrate "La puerta se abre, rechinando, mientras hiedras y hierbas se rompen en su trazado."
  short_pause
  narrate "Ambrosio, alegre, se despide de ti."
  speak "Estoy seguro de que volveremos a vernos"&r_quote$&", dice."
  narrate "Se ha ido."
  do_vanish ambrosio
  do_vanish the_key
  let thing_description$(the_door)="Entreabierta."
  let thing_description$(the_lock)="Abierto."
  let location_exit(47,west)=48

enddef

rem --------------------------------------------
rem Analizador
rem Parser

defproc command

  rem Acepta un comando, lo analiza y lo ejecuta.

  loc next_space,command$

  let action=false
  let object=false
  let complement=false
  let command$=accept$

  rep find_word
    let next_space=" " instr command$
    parse_word command$(1 to next_space-1)
    if next_space=len(command$):exit find_word
    let command$=command$(next_space+1 to)
  endrep find_word

  if fine_command:do_action action

enddef

defproc parse_word(word$)

  rem Analiza la palabra dada.

  if not action
    let action=parse_action(word$)
  else
    if not object
      let object=parse_noun(word$)
    else
      if not complement:complement=parse_noun(word$)
    endif
  endif

enddef

deffn parse_action(word$)

  rem Analiza la palabra dada,
  rem tras suponer que es un verbo.

  loc found
  let found=inarray%(verb$,0,word$)
  if found<0:ret 0
  ret the_action(found)

enddef

deffn parse_noun(word$)

  rem Analiza la palabra dada,
  rem tras suponer que es un sustantivo.

  loc found
  let found=inarray%(noun$,0,word$)
  if found<0:ret 0
  ret the_thing(found)

enddef

deffn fine_command

  rem Comprueba si el comando es correcto,
  rem tanto por las partes que lo componen
  rem como por la accesibilidad de objeto y complemento.
  rem Devuelve 1 si es correcto y 0 en caso contrario.

  loc syntax
  let syntax=action_syntax(action)

  if not action:narrate "No conozco ese verbo.":ret 0

  sel on syntax
    =object_needed:if not object:narrate not_seen$:ret 0
    =object_and_complement_needed:if (not object or not complement):narrate not_seen$:ret 0
  endsel

  if object:if not is_it_accessible(object):narrate not_seen$:ret 0
  if complement:if not is_it_accessible(complement):narrate not_seen$:ret 0

  ret 1

enddef

rem --------------------------------------------
rem Acciones
rem Actions

defproc do_action(action)

  rem Ejecuta la acción dada.

  sel on action
    =to_break:action_break
    =to_drop:action_drop
    =to_examine:action_examine
    =to_finish:action_end
    =to_fling:action_fling
    =to_go_down:action_move down
    =to_go_east:action_move east
    =to_go_north:action_move north
    =to_go_south:action_move south
    =to_go_up:action_move up
    =to_go_west:action_move west
    =to_help:action_help
    =to_insert:action_insert
    =to_look:action_look
    =to_open:action_open
    =to_speak:action_speak
    =to_swim:action_swim
    =to_take:action_take
    =remainder:narrate "No puedes hacer eso."
  endsel

enddef

defproc action_help
  narrate "Direcciones: n[orte], s[ur], e[ste], o[este], arriba y abajo."
  narrate "m[irar] redescribe un lugar, ex[aminar] permite examinar un objeto, o en su defecto a ti."
  narrate "Se puede cortar, nadar, atacar, empujar, golpear, coger, dejar, tirar..."
  narrate "Se aceptan formas verbales en infinitivo e imperativo; y diversos sinónimos tanto de verbos como de nombres."
  narrate "El atajo de teclado Ctrl+B (des)activa el bip de error de tecleo."

enddef

defproc action_examine

  if object
    if is_it_accessible(object)
      narrate thing_description$(object)
    else
      narrate not_seen$
    endif
  else
    action_inventory
  endif

enddef

defproc action_end

  if yes("¿Quieres volver a intentarlo?")
    let start_over=true
  else
    clear_screen:stop
  endif

enddef

defproc action_swim

  if current_location=11
    clear_screen
    narrate "Caes hacia el fondo por el peso de tu coraza. Como puedes, te desprendes de ella y buceas, pensando en avanzar, aunque perdido."
    short_pause
    narrate "Consigues emerger, si bien en un sitio desconocido de la caverna..."
    end_of_scene
    let current_location=12
    action_look
  else
    narrate "No tiene sentido nadar ahora."
  endif

enddef

defproc action_open

  if current_location=47
    if object=the_door or object=the_lock
      if is_it_accessible(the_key)
        open_the_door
      else
        narrate "El candado bloquea la puerta."
      endif
    else
      narrate "No tiene sentido abrir eso."
    endif
  else
    narrate "No hay nada que abrir ahora."
  endif

enddef

defproc action_drop

  sel on object
    =the_sword:if current_location<12:narrate "No, es lo que queda de mi padre.":ret
    =the_torch:if lit_the_torch:narrate "No, sin luz es imposible moverse por la caverna.":ret
  endsel
  if location(object)=ulfius
    let location(object)=current_location
    narrate "Hecho."
  else
    narrate i_dont_have_it$
  endif
enddef

defproc action_take

  if location(object)=ulfius
    narrate "Pero si ya lo tengo..."
  else
    if cannot_be_taken(object)
      if object=the_key
        narrate "Ambrosio la retiene consigo."
      else
        narrate "No es algo que se pueda coger."
      endif
    else
      let location(object)=ulfius:narrate "Hecho."
    endif
  endif

enddef

defproc action_break

  if not complement and is_it_accessible(the_sword)
      let complement=the_sword
  endif

  sel on object

    =the_log

      if hacked_the_log
        narrate "La punta ya es lo suficientemente afilada."
      else
        sel on complement
          =false:narrate not_by_hand$
          =the_sword
            narrate "Sabes que el resultado es la hoja de tu espada, mellada. No."
          =the_flint
            let hacked_the_log=true
            let thing_description$(the_log)=thing_description$(the_log)&" Su punta está afilada."
            narrate "Con el pedernal, recortas la punta del tronco."
          =remainder
            narrate "El problema es encontrar la herramienta adecuada para hacerlo."
        endsel
      endif

    =the_cloak

      sel on complement
        =false:narrate not_by_hand$
        =the_sword
          do_vanish the_cloak
          let location(the_rags)=ulfius
          let location(the_thread)=ulfius
          let location(the_piece)=ulfius
          narrate "Rasgas la capa, como buenamente puedes."
        =remainder
          narrate not_with_that$
      endsel

    =the_rocks

      sel on complement
        =false:narrate not_by_hand$
        =the_log:rocks_and_log
        =the_sword:narrate "Tu espada no hace nada."
        =remainder:narrate not_with_that$
      endsel

    =the_flint

      sel on complement
        =false:narrate not_by_hand$
        =the_sword
          if is_it_accessible(the_torch)
            let lit_the_torch=true
            let thing_description$(the_torch)="Ilumina perfectamente."
            narrate "Poderosas chispas salen del choque entre espada y pedernal, encendiendo la antorcha."
          else
            narrate "Ante el potente choque con la espada, poderosas chispas saltan en todas direcciones."
          endif
        =remainder:narrate not_with_that$
      endsel

    =the_snake

      sel on complement
        =false:narrate not_by_hand$
        =the_sword
          narrate "Ante los amenazadores tajos, la serpiente huye."
          do_vanish the_snake
          let location_exit(43,south)=44
        =remainder:narrate not_with_that$
      endsel

    =remainder:narrate "Eso no es lo adecuado ahora."

  endsel 

enddef

defproc action_speak

  sel on object
    =ambrosio:talk_to_ambrosio
    =the_man:talk_to_the_man
    =remainder:narrate "No tiene sentido hablar con eso."
  endsel

enddef

defproc talk_to_ambrosio

  if location(ambrosio)=19

    speak "Hola, buen hombre."
    speak "Hola, Ulfius. Mi nombre es Ambrosio."
    end_of_scene
    clear_screen
    narrate "Por primera vez, Ulfius se sienta y cuenta a Ambrosio todo lo que ha pasado. Y tras tanto acontecido, llora desconsoladamente."
    end_of_scene
    clear_screen
    narrate "Ambrosio le propone un trato, que acepta: por ayudarle a salir de la cueva, objetos, vitales para la empresa, le son entregados."
    let location(the_torch)=ulfius
    let location(the_flint)=ulfius
    short_pause
    speak "Bien, Ambrosio, emprendamos la marcha."
    let location(ambrosio)=46
    narrate "Ulfius se da la vuelta para ver si Ambrosio le sigue, pero... ha desaparecido."
    short_pause
    narrate "Ulfius piensa entonces en el hecho curioso de que supiera su nombre."
    end_of_scene
    clear_screen

  else

    if current_location=46
      if not ambrosio_follows
        speak "La llave, Ambrosio, estaba ya en tu poder. Y es obvio que conocéis un camino más corto."
        speak "Estoy atrapado en la cueva debido a magia de maligno poder. En cuanto al camino, vos debéis hacer el vuestro, verlo todo con vuestros ojos."
        narrate "Ulfius sacude la cabeza."
        speak "No lo entiendo, la verdad."
      endif
    endif
    if current_location>=45 and current_location<=47
      speak "Por favor, Ulfius, cumple tu promesa. Toma la llave en tu mano y abre la puerta de la cueva."
      let location(the_key)=ulfius
      let thing_type(the_key)=0
      let ambrosio_follows=true
    endif

  endif

enddef

defproc talk_to_the_man

  if not talked_to_the_man
    speak "Me llamo Ulfius y..."
    let talked_to_the_man=true
    narrate "El hombre asiente, impaciente."
    speak "Somos refugiados de la gran guerra. Buscamos la paz."
    short_pause
  endif
  if is_it_accessible(the_stone)
    narrate "El hombre se irrita."
    speak "No podemos permitiros huir con la piedra del druida."
    narrate "Hace un gesto..."
    short_pause
    speak "La piedra debe devolverse a su lugar de encierro."
    narrate "Un hombre te arrebata la piedra y se la lleva."
    let location(the_stone)=18
  else
    if is_it_accessible(the_sword)
      narrate "El hombre se enfurece, y alza su mano indicando al norte."
      speak "Nadie portando armas puede pasar."
    else
      let location_exit(28,east)=29
      narrate "El hombre, calmado, indica hacia el este y habla:"
      speak "Si vienes en paz, puedes ir en paz."
      narrate "Todos se apartan y permiten ahora el paso al este."
    endif
  endif

enddef

defproc action_fling

  sel on current_location
    =13,16
      narrate "No hay suficiente profundidad."
    =19 
      if (object=the_sword or object=the_stone) and talked_to_the_man
        let location(object)=39
        narrate "La corriente lo arrastra fuertemente, hasta perderlo de vista."
      else
        narrate "No quieres perder eso.":rem add name!!!
      endif
    =remainder:
      narrate "No tiene sentido tirar nada ahora."
  endsel

enddef

defproc action_insert

  sel on complement
    =the_rocks
      if object=the_log
        rocks_and_log
      else
        narrate "No tiene sentido meter eso ahí."
      endif
    =the_idol
      sel on object
        =the_emerald,the_stone
          do_vanish object
          narrate "Encaja. Metido. Desaparece en su interior."
          if is_it_vanished(the_stone) and is_it_vanished(the_emerald)
            let location_exit(41,south)=42
            narrate "La gran roca se desplaza y deja el paso libre."
          endif
        =remainder
          narrate "No encaja."
      endsel
    =the_lock
      if object=the_key
        narrate "La llave gira fácilmente dentro del candado."
        short_pause
        open_the_door
      else
        narrate "No tiene sentido meter eso ahí."
      endif
    =remainder
      narrate "No tiene sentido meter nada en eso."
  endsel

enddef

defproc action_move(direction)

  if location_exit(current_location,direction)
    let current_location=location_exit(current_location,direction)
    action_look
  else
    narrate "No es posible."
  endif

enddef

defproc action_inventory

  loc i,list$
  let list$=""

  for i=1 to things
    if location(i)=ulfius:let list$=list$&"  - "&thing$(i)&nl$
  endfor i
  if len(list$)
    narrate "Llevo conmigo:"&nl$&list$
  else
    narrate "No llevo nada conmigo."
  endif

enddef

defproc action_look

  clear_screen
  describe location_description$(current_location)
  location_plot
  list_present_things 

enddef

defproc list_present_things

  loc n,list$

  let list$=""
  for n=1 to things
    if location(n)=current_location
      if is_it_a_person(n)
        let list$=list$&"  - "&iso_upper_1$(thing$(n))&nl$
      else
        let list$=list$&"  - "&thing$(n)&nl$
      endif
    endif
  endfor n
  if len(list$)
    narrate "Puedes ver:"&nl$&list$
  endif

enddef

rem --------------------------------------------
rem Intefaz de datos
rem Data interface

deffn is_it_a_person(thing)

  ret thing_type(thing)=2

enddef

defproc do_takeable(thing)

  let thing_type(thing)=false

enddef

defproc do_not_takeable(thing)

  let thing_type(thing)=true

enddef

deffn can_be_taken(thing)

  ret not thing_type(thing)

enddef

deffn cannot_be_taken(thing)

  ret thing_type(thing)

enddef

deffn is_it_here(thing)

  ret location(thing)=current_location

enddef

deffn is_it_hold(thing)

  ret location(thing)=ulfius

enddef

deffn is_it_accessible(thing)

  if thing<1:narrate "is_it_accessible("&thing&")!":stop:rem debug!!! tmp!!!
  ret is_it_hold(thing) or is_it_here(thing)

enddef

defproc do_vanish(thing)

  let location(thing)=limbo

enddef

deffn is_it_vanished(thing)

  ret location(thing)=limbo

enddef

rem --------------------------------------------
rem Entrada
rem Input

deffn iso_input$(channel,max_chars)

  rem Devuelve un texto introducido por el teclado.

  rem channel =
  rem Canal de la ventana en que se recibirá y mostrará el texto, a partir de la posición actual del cursor.
  rem max_chars =
  rem Longitud máxima del texto; si es cero, será la máxima posible a partir de la posición actual del cursor en la en la ventana, calculada con el tamaño actual de letra.

  rem Los caracteres castellanos son convertidos
  rem al estándar ISO 8859-1; todas las letras
  rem son convertidas a minúsculas;
  rem no permite teclear espacios iniciales,
  rem dobles espacios, dígitos o signos de puntuación.

  loc output$,key$,key,cursor_pos,cursor_x0,cursor_y0

  let output$=""
  let cursor_pos=1
  let cursor_x0=pos_x(#channel)
  let cursor_y0=pos_y(#channel)
  if max_chars=0
    let max_chars=char_x(#channel)-cursor_x0/char_w(#channel)-2
  endif
  cursen #channel
  rep typing
    rem print "POS="!cursor_pos!"<";output$;">"!"LEN="!len(output$):rem debug!!!
    let key$=inkey$(#channel,-1)
    let key=code(key$)
    rem at 0,0:print key:rem debug!!!
    sel on key
      =2:let mistype_bell_active=not mistype_bell_active:rem Ctrl+B
      =enter:exit typing
      =space:type_space
      =65 to 90:type chr$(key+32)
      =97 to 122:type key$
      =131,163:type chr$(233) : rem e/E with acute
      =135,167:type chr$(252) : rem u/U with diaeresis
      =137,169:type chr$(241) : rem n/N with tilde
      =140:type chr$(225) : rem a with acute
      =147:type chr$(237) : rem i with acute
      =150:type chr$(243) : rem o with acute
      =153:type chr$(250) : rem u with acute
      =192:cursor_left
      =193:rem start of line
        let cursor_pos=1
        set_cursor cursor_pos
      =194:backspace_char
      =196:previous_word
      =200:cursor_right
      =201:rem end of line
        let cursor_pos=len(output$)+1
        set_cursor cursor_pos
      =202:delete_char
      =204:next_word
    endsel 
  endrep typing
  curdis #channel
  print #channel\\\
  ret output$

enddef

defproc type(char$)

  rem Si hay espacio,
  rem añade al texto el caracter indicado y lo imprime.

  if len(output$)<max_chars
    sel on cursor_pos
    =len(output$)+1:rem print "=len+1!"
      let output$=output$&char$
      let cursor_pos=cursor_pos+1
      show_input
    =remainder
      let output$=output$(1 to cursor_pos-1)&char$&output$(cursor_pos to)
      show_input
    endsel
  else
    mistype_bell
  endif

enddef

defproc type_space

  if cursor_pos=1
    mistype_bell
  else
    if cursor_pos>len(output$)
      if output$(cursor_pos-1)=" "
        mistype_bell
      else
        type " "
      endif
    else
      if output$(cursor_pos)=" " or output$(cursor_pos-1)=" "
        mistype_bell
      else
        type " "
      endif
    endif
  endif

enddef

defproc mistype_bell

  if mistype_bell_active:beep 1000,0

enddef

defproc backspace_char

  rem Si corresponde, borra el carácter a la izquierda del cursor

  loc original$

  if len(output$)
    if cursor_pos=1
        mistype_bell
    else
      let original$=output$
      let output$=original$(1 to cursor_pos-2)
      if cursor_pos<=len(original$)
        let output$=output$&original$(cursor_pos to)
      endif
      let cursor_pos=cursor_pos-1
      show_input
    endif
  else
    mistype_bell
  endif

enddef

defproc delete_char

  rem Si es posible, borra el carácter bajo el cursor.

  loc original$

  if len(output$)
    if cursor_pos=len(output$)+1
      mistype_bell
    else
      let original$=output$
      let output$=original$(1 to cursor_pos-1)
      if cursor_pos<len(original$)
        let output$=output$&original$(cursor_pos+1 to)
      endif
     show_input
    endif
  else
    mistype_bell
  endif

enddef

defproc cursor_left

  rem Si es posible, desplaza el cursor un carácter a la izquierda.

  if cursor_pos>1
    curdis #channel
    let cursor_pos=cursor_pos-1
    set_cursor cursor_pos
    cursen #channel
  else
    mistype_bell
  endif

enddef

defproc cursor_right

  rem Si es posible, desplaza el cursor un carácter a la derecha.

  if cursor_pos<len(output$)+1
    curdis #channel
    let cursor_pos=cursor_pos+1
    set_cursor cursor_pos
    cursen #channel
  else
    mistype_bell
  endif

enddef

defproc previous_word

  rem Si es posible, desplaza el cursor al inicio de la palabra anterior.

  loc temp
  loc from_char,to_char

  if cursor_pos=1

    mistype_bell

  else

    let temp=0
    let to_char=code(output$(cursor_pos-(cursor_pos>len(output$))))
    let from_char=to_char

    rep search
      if not ((cursor_pos>1) and not(from_char<>space and to_char=space and temp>1)):exit search
        let from_char=to_char
        let cursor_pos=cursor_pos-1
        let temp=temp+1
        let to_char=code(output$(cursor_pos))
    endrep search
    let cursor_pos=cursor_pos+(cursor_pos<>1)
    set_cursor cursor_pos
    show_input

  endif

enddef

defproc next_word

  rem Si es posible, desplaza el cursor al inicio de la palabra siguiente (o al final de la última palabra).

  loc from_char,to_char

  if cursor_pos>len(output$)
    mistype_bell
  else
    let to_char=code(output$(cursor_pos))
    let from_char=to_char
    rep search
    if not ((cursor_pos<len(output$)) and not(from_char=space and to_char<>space)):exit search
      let from_char=to_char
      let cursor_pos=cursor_pos+1
      let to_char=code(output$(cursor_pos))
    endrep search
    let cursor_pos=cursor_pos+(cursor_pos=len(output$))
    set_cursor cursor_pos
    show_input
  endif

enddef

defproc show_input

  rem Muestra el texto que está siendo introducido

  curdis #channel
  set_cursor 1
  print #channel,output$;
  cls #channel,4
  rem print #channel,output$;fill$(" ",max_chars-len(output$))
  set_cursor cursor_pos
  cursen #channel

enddef

defproc set_cursor(column)

  rem Sitúa el cursor de texto en la posición
  rem de pixeles correspondiente a la columna indicada
  rem (que es relativa al texto que se está escribiendo).

  cursor #channel,cursor_x0+(column-1)*char_w(#channel),cursor_y0

enddef

deffn yes(question$)

  rem Muestra la pregunta indicada
  rem y espera la pulsación de las teclas S o N
  rem (sin distinguir minúsculas de mayúsculas).
  rem Devuelve 1 si se pulsó S; 0 si se pulsó N.

  loc answer$

  print #tw,question$!"(S/N)"!;
  rep answer
    let answer$=inkey$(#tw)
    if answer$ instr "sn":exit answer
  endrep answer
  ret answer$ instr "s"

enddef

defproc end_of_scene:rem rename?!!!

  rem Muestra un presto para que se pulse una tecla y hace una pausa larga.
  rem Se usa para terminar escenas, generalmente seguidas de un borrado de pantalla.

  ink #tw,dark_green
  print #tw,"..."\\
  wait_for_key_press(16)

enddef

defproc short_pause

  rem Hace una corta pausa entre ciertos párrafos de la narración.

  wait_for_key_press(2)

enddef

defproc wait_for_key_press(seconds)

  rem Espera los segundos indicados, o hasta que se pulse una tecla.

  loc start_time
  let start_time=date

  rep dont_press_a_key
    if inkey$(#tw)="" or date>start_time+seconds
      exit dont_press_a_key
    endif
  endrep dont_press_a_key
  rep press_a_key
    if inkey$(#tw)<>"" or date>start_time+seconds
      exit press_a_key
    endif
  endrep press_a_key

enddef

deffn accept$
  loc command$
  ink #tw,yellow
  rep waiting_for_command
    print #tw,"> ";
    let command$=iso_input$(#tw,0)
    if len(command$):exit waiting_for_command
  endrep waiting_for_command
  if command$(len(command$))<>" ":let command$=command$&" "
  ink #tw,light_grey
  ret command$
enddef

rem --------------------------------------------
rem Cadenas
rem Strings

deffn iso_upper(char)

  loc c:rem QDOS y Minerva necesitan esto, pues no pueden usar el parámetro como selector en SELect
  let c=char
  sel on c
    =97 to 122:ret c-32
    =remainder:ret c
  endsel

enddef

deffn iso_upper$(text$)

  loc i,upper_text$
  let upper_text$=text$
  for i=1 to len(upper_text$)
    let upper_text$(i)=chr$(iso_upper(code(text$(i))))
  endfor i
  ret upper_text$

enddef

deffn iso_upper_1$(text$)

  ret iso_upper$(text$(1))&text$(2 to)

enddef

rem --------------------------------------------
rem Pantalla
rem Screen

defproc clear_screen

  ink #tw,light_grey
  cls #tw

enddef

defproc full_screen(channel)

  rem tmp!!!
  rem From the Display toolkit, by Dilwyn Jones.
  loc sw,sh,sx,sy
  let sw=flim_w(#channel)
  let sh=flim_h(#channel)
  let sx=flim_x(#channel)
  let sy=flim_y(#channel)
  window #channel,sw,sh,sx,sy

enddef

rem --------------------------------------------
rem Tipos 
rem Fonts

defproc fonts(font_address)

  char_use#tw,font_address,0 

enddef

defproc iso_font

  fonts font_address

enddef

defproc ql_font

  fonts 0

enddef

defproc init_the_font

  loc font_size
  let font$=dev$&"iso_8859-1_font"
  font_size=flen(\font$)
  font_address=alchp(font_size)
  lbytes font$,font_address
  iso_font

enddef

rem --------------------------------------------
rem Salida de textos
rem Text output

defproc speak(quote$)

  loc last
  ink #tw,yellow
  if r_quote$ instr quote$
    tell l_quote$&quote$
  else
    let last=len(quote$)
    if quote$(last)="." and quote$(last-1)<>"."
      tell l_quote$&quote$(1 to last-1)&r_quote$&"."
    else
      tell l_quote$&quote$(1 to last)&r_quote$
    endif
  endif

enddef

defproc describe(txt$)

  ink #tw,dark_cyan:tell txt$

enddef

defproc narrate(txt$)

  ink #tw,light_grey:tell txt$

enddef

defproc tell(txt$)

  loc text$,first,last

  if len(txt$)
    let text$=txt$&" "
    let first=1
    for last=1 to len(text$)
      if text$(last)=" "
        print #tw,!text$(first to last-1);
        let first=last+1
      endif
    endfor last
  endif
  print #tw,\\

enddef

rem --------------------------------------------
rem Acerca de
rem About

defproc credits

  clear_screen
  ink #tw,light_red:print #tw,"Asalto y castigo"
  ink #tw,dark_cyan
  print #tw,\"Por Baltasar el Arquero, 2009"
  print #tw,"http://caad.es/baltasarq/"
  print #tw,\"Reescrita en SuperBASIC para QL por"
  print #tw,"Marcos Cruz (programandala.net), 2011"
  print #tw,"http://programandala.net/"
  print #tw,"Versión"!version$
  ink #tw,light_grey
  print #tw,\\"http://www.caad.es/"
  print #tw,"http://www.sinclairql.es/"\\\

enddef

defproc intro

  clear_screen
  narrate "El sol despunta de entre la niebla, haciendo humear los tejados de paja."
  short_pause
  narrate "Piensas en el encargo realizado por Uther Pendragón. Atacar una aldea tranquila, aunque sea una llena de sajones, no te llena de orgullo."
  short_pause
  narrate "Los hombres se ciernen sobre la aldea, y la destruyen. No hubo tropas enemigas, ni honor en la batalla."
  end_of_scene
  clear_screen
  speak "Sire Ulfius, la batalla ha terminado."
  narrate "Lentamente, das la orden de volver a casa. Los oficiales detienen como pueden el saqueo."
  end_of_scene
  clear_screen

enddef

rem --------------------------------------------
rem Inicialización
rem Init

defproc init_the_system

  rem unfinished!!!
  tk2_ext
  if ver$="HBA"
    let dev$="dos1_sb_ayc_"
  else
    let dev$="flp1_"
  endif
  rem lrespr dev$&"ext_exists.bin"
  if not here("gd2")
    rem lrespr dev$&"ext_display.cde"
  endif
  if not here("maximum")
    lrespr dev$&"ext_minmax_code"
  endif

enddef

defproc init_256_colours

    rem QL colours in mode 16 (8 bits, 256 colours):
    let black=0:rem used!!!
    let blue=4
    let red=2:rem used!!!
    let purple=20
    let green=3
    let cyan=7
    let yellow=6:rem used!!!
    let white=1
    rem Original Blassic/CPC colours:
    let dark_blue=19
    let dark_green=17:rem used!!!
    let dark_cyan=cyan:rem used!!! 008B8B
    let brown=46
    let light_grey=12:rem used!!!
    let dark_grey=10
    let light_blue=29
    let light_green=15
    let light_cyan=0:rem E0FFFF
    let light_red=red:rem used!!! unfinished!!!
    let light_purple=purple:rum unfinished!!!

enddef

defproc init_8_colours

    rem QL colours in mode 8 (4 bits, 8 colours):
    let black=0:rem used!!!
    let blue=1
    let red=2:rem used!!!
    let purple=3
    let green=4
    let cyan=5
    let yellow=6:rem yellow!!!
    let white=7
    rem Original Blassic/CPC colours:
    let dark_blue=blue
    let dark_green=green:rem used!!!
    let dark_cyan=cyan:rem used!!!
    let brown=red
    let light_grey=white:rem used!!!
    let dark_grey=white
    let light_blue=cyan
    let light_green=green
    let light_cyan=cyan
    let light_red=red:rem used!!!
    let light_purple=purple

enddef

defproc init_the_screen

  rem unfinished!!!

  if gd2(#0)
    sel on disp_type
      =0:mode 8:init_8_colours
      =8:init_8_colours
      =16:init_256_colours
      =32:colour_pal:init_256_colours
    endsel
  else
    if not dmode:mode 8
    init_8_colours
  endif

  let scr_w=flim_w(#0)
  let scr_h=flim_h(#0)

enddef

defproc init_the_windows

  let csize_w=3-(scr_w=512)
  let csize_h=scr_w>512

  rem Background window (bw)
  let bw_w=scr_w
  let bw_h=scr_h
  let bw_x=0
  let bw_y=0
  let bw=fopen("scr_")
  window #bw,bw_w,bw_h,bw_x,bw_y
  paper #bw,black
  cls #bw

  let bw_border=8
  let border_gap=8:rem pixels between the background border and the main window

  rem Main window (mw)
  rem unfinished!!!
  let mw=fopen("scr_")
  let mw_w=minimum(800,scr_w)
  let mw_h=minimum(600,scr_h)
  let mw_x=(scr_w-mw_w)/2
  let mw_y=(scr_h-mw_h)/2
  let mw_border=8
  if 0
  window #mw,mw_w,mw_h,mw_x,mw_y
  paper #mw,black
  cls #mw
  endif

  rem Text window (tw)
  let tw=fopen("con_")
  csize #tw,csize_w,csize_h
  let tw_w=mw_w-2*mw_border-2*border_gap
  let tw_h=mw_h-2*mw_border-2*border_gap
  let tw_x=mw_x+(mw_w-tw_w)/2
  let tw_y=mw_y+(mw_h-tw_h)/2
  window #tw,tw_w,tw_h,tw_x,tw_y
  paper #tw,black
  ink #tw,light_grey
  cls #tw

  init_the_font

enddef

defproc first_time_init

  init_the_system
  init_the_screen
  init_the_windows
  init_the_constants
  init_the_preferences

enddef

defproc game_init

  loc y
  let y=pos_y(#tw)
  print #tw,"Preparando los datos..."
  init_the_flags
  init_the_data
  let current_location=1
  cls #tw,3
  cursor #tw,0,y

enddef

defproc init_the_preferences

  let mistype_bell_active=true

enddef

defproc init_the_constants

  rem Varios
  rem Misc
  let space=32:rem char code
  let enter=10:rem char code
  let nl$=chr$(enter):rem new line
  let l_quote$="«":rem castilian left quote
  let r_quote$="»":rem castilian right quote
  let limbo=255:rem location of vanished things

  rem Action syntax flags
  rem Indicadores de sintaxis de las acciones
  let no_object_needed=0
  let object_needed=1
  let object_and_complement_needed=2

  rem Mensajes de error
  rem Error messages 
  rem tmp!!!
  let not_seen$="No lo veo, o no es importante."
  let i_dont_have_it$="No llevo eso conmigo."
  let not_with_that$="Con eso no..."
  let not_by_hand$="En cualquier caso, no con las manos desnudas."

  rem Identificadores de acciones
  rem Action ids

  let to_go_down = 1
  let to_open =2
  let to_go_up = 3
  let to_break =4
  let to_help = 5
  let to_swim = 6
  let to_take = 7
  let to_drop = 8
  let to_go_east = 9
  let to_examine = 10
  let to_talk = 11
  let to_insert = 12
  let to_look = 13
  let to_go_north = 14
  let to_go_west = 15
  let to_go_south = 16
  let to_finish = 17
  let to_fling = 18

  rem Identificadores de cosas
  rem Thing ids
  let ulfius=0
  let the_altar=1
  let ambrosio=2
  let the_torch=3
  let the_flags=4
  let the_cloak=5
  let the_waterfall=6
  let the_fallen_away=7
  let the_emerald=8
  let the_sword=9
  let the_rags=10
  let the_thread=11
  let the_man=12
  let the_idol=13
  let the_lake=14
  let the_key=15
  let the_flint=16
  let the_stone=17
  let the_door=18
  let the_rocks=19
  let the_snake=20
  let the_log=21
  let the_piece=22
  let the_lock=23

  rem Direction ids
  let north=0
  let south=1
  let east=2
  let west=3
  let up=4
  let down=5
  let first_direction=north
  let last_direction=down

enddef

defproc init_the_flags

  let ambrosio_follows=false
  let saxons_follow=false
  let talked_to_the_man=false
  let hacked_the_log=false
  let lit_the_torch=true
  let start_over=false

enddef

defproc init_the_data

  loc i,j,max_word_lenght,action

  let max_word_lenght=11

  rem Note!!!:
  rem the first (0) element of arrays is not used.

  restore

  let locations=lines_between("label_location_descriptions_start","label_location_descriptions_end")
  dim location_description$(locations,255)
  for i=1 to locations
    read location_description$(i)
  endfor i

  dim location_exit(locations,last_direction)
  for i=1 to locations
    for j=first_direction to last_direction
      read location_exit(i,j)
    endfor j
  endfor i

  let nouns=lines_between("label_nouns_start","label_nouns_end")
  dim noun$(nouns,max_word_lenght)
  dim the_thing(nouns)
  let things=lines_between("label_things_start","label_things_end")/2
  dim thing$(things,max_word_lenght)

  for i=1 to nouns
    read the_thing(i),noun$(i)
    let thing$(the_thing(i))=noun$(i):rem the last synonym on the list will be the actual name
  endfor i

  dim location(things)
  dim thing_type(things)
  dim thing_description$(things,128)
  for i=1 to things
    read thing
    read location(thing),thing_type(thing)
    read thing_description$(thing)
  endfor i

  let actions=lines_between("label_actions_start","label_actions_end")
  dim action_syntax(actions)
  for i=1 to actions
    read action
    read action_syntax(action)
  endfor i

  let verbs=lines_between("label_verbs_start","label_verbs_end")
  dim verb$(verbs,max_word_lenght)
  dim the_action(verbs)
  let action=1
  let last_action=0
  for i=1 to verbs
    read the_action(i),verb$(i)
  endfor i

enddef

rem --------------------------------------------
rem Datos
rem Data

rem Location descriptions

defproc label_location_descriptions_start:enddef
data "Aldea Sajona. No ha quedado nada en pie, ni piedra sobre piedra. El entorno es desolador. Solo resta volver al sur, a casa."
data "Sobre la colina, casi sobre la niebla de la aldea sajona arrasada al norte, a tus pies. El camino desciende hacia el oeste."
data "Camino entre colinas. El camino avanza por el valle, desde la parte alta, al este, a una zona harto boscosa, al oeste."
data "Cruce de caminos. Una senda parte al oeste, a la sierra por el paso del Perro, y otra hacia el norte, por un frondoso bosque que la rodea."
data "Desde la linde, al sur, hacia el oeste se extiende frondoso el bosque que rodea la sierra. La salida se abre hacia el sur."
data "Bosque. Jirones de niebla se enzarcen en frondosas ramas y arbustos. La senda serpentea entre raíces, de un luminoso este al oeste."
data "Paso del Perro. Abruptamente, del bosque se pasa a un estrecho camino entre altas rocas. El inquietante desfiladero tuerce de este a sur."
data "Entrada a la cueva. El paso entre el desfiladero sigue de norte a este. La entrada a una cueva se abre al sur en la pared de roca."
data "Derrumbe. El camino desciende hacia la agreste sierra, al oeste, desde los verdes valles al este. Pero un gran derrumbe bloquea la sierra."
data "Gruta de entrada. El estrecho paso se adentra hacia el oeste, desde la boca, al norte. "
data "Gran lago. Una gran estancia alberga un lago de profundas e iridiscentes aguas, debido a la luz exterior. No hay otra salida que el este."
data "Salida del paso secreto. Una gran estancia se abre hacia el oeste, y se estrecha hasta morir, al este, en una parte de agua."
data "Puente semipodrido. La sala se abre en semioscuridad a un puente cubierto de podredumbre sobre el lecho de un canal, de este a oeste."
data "Recodo de la cueva. La iridiscente cueva gira de este a sur."
data "Pasaje arenoso. La gruta desciende de norte a sur sobre un lecho arenoso. Al este, un agujero del que llega claridad."
data "Pasaje del agua. Como un acueducto, el agua baja con gran fuerza de norte a este, aunque la salida practicable es la del oeste."
data "Estalactitas. Muchas estalactitas se agrupan encima de tu cabeza, y se abren cual arco de entrada hacia el este y sur."
data "Puente de piedra. Un arco de piedra se eleva, cual puente sobre la oscuridad, de este a oeste. En su mitad, un altar."
data "Recodo arenoso del canal. La furiosa corriente, de norte a este, impide el paso, excepto al oeste. Al fondo, se oye un gran estruendo."
data "Un tramo de cueva estrecho te permite avanzar hacia el norte y el sur; un pasaje surge al este."
data "Un tramo de cueva estrecho te permite avanzar de este a oeste; un pasaje surge al sur."
data "Un tramo de cueva estrecho te permite avanzar de este a oeste; un pasaje surge al sur."
data "Un tramo de cueva estrecho te permite avanzar de oeste a sur."
data "Un tramo de cueva estrecho te permite avanzar de este a norte."
data "Un tramo de cueva estrecho te permite avanzar de este a oeste. Al norte y al sur surgen pasajes."
data "Un tramo de cueva estrecho te permite avanzar de este a oeste. Al norte surge un pasaje."
data "Un tramo de cueva estrecho te permite avanzar al oeste. Al norte surge un pasaje."
data "Refugio. Una amplia estancia de norte a este, hace de albergue a refugiados: hay banderas de ambos bandos. Un hombre anciano te contempla. Los refugiados te rodean."
data "Espiral. Cual escalera de caracol gigante, desciende a las profundidades, dejando a los refugiados al oeste."
data "Inicio de la espiral. Se eleva en la penumbra. La caverna se estrecha ahora como para una sola persona, hacia el este."
data "Puerta norte. En este pasaje grandes rocas se encuentran entre las columnas de un arco de medio punto."
data "Precipicio. El camino ahora no excede de dos palmos de cornisa sobre un abismo insondable. El soporte de roca gira en 'U' de oeste a sur."
data "Pasaje de salida. El paso se va haciendo menos estrecho a medida que se avanza hacia el sur, para entonces comenzar hacia el este."
data "Pasaje de gravilla. El paso se anchea de oeste a norte, y guijarros mojados y mohosos tachonan el suelo de roca."
data "Puente sobre el acueducto. Un puente se tiende de norte a sur sobre el curso del agua. Resbaladizas escaleras descienden hacia el oeste."
data "Remanso. Estruendosa corriente baja con el pasaje elevado desde el oeste, y forma un meandro arenoso. Unas escaleras suben al este."
data "Canal de agua. El agua baja del oeste con renovadas fuerzas, dejando un estrecho paso elevado lateral para avanzar a este o a oeste."
data "Gran Cascada. Cae el agua hacia el este, descendiendo con gran fuerza hacia el canal, no sin antes embalsarse en un lago poco profundo."
data "Interior de la cascada. Musgoso y rocoso, con la cortina de agua tras de ti, el nivel del agua ha crecido un poco en este curioso hueco."
data "Explanada. Una gran explanda enlosetada contempla un bello panorama de estalactitas. Unos casi imperceptibles escalones conducen al este."
data "Ídolo. El ídolo parece un centinela siniestro de una gran roca que se encuentra al sur. Se puede volver a la explanada al oeste."
data "Pasaje estrecho. Como un pasillo que corteja el canal de agua, a su lado, baja de norte a sur. Se aprecia un aumento de luz hacia el sur."
data "Pasaje de la serpiente. El pasaje sigue de norte a sur."
data "Lago interior. Unas escaleras dan paso a un hermoso lago interior, y siguen hacia el oeste. Al norte, un oscuro y estrecho pasaje sube."
data "Cruce de pasajes. Estrechos pasos permiten ir al oeste, al este (menos oscuro), y al sur, un lugar de gran luminosidad."
data "Hogar de Ambrosio. Un catre, algunas velas y una mesa es todo lo que tiene Ambrosio."
data "Salida de la cueva. Por el oeste, una puerta impide, cuando cerrada, la salida de la cueva. Se adivina la luz diurna al otro lado."
data "Bosque a la entrada. Apenas se puede reconocer la entrada de la cueva, al este. El sendero sale del bosque hacia el oeste."
data "Sendero del bosque. El sendero recorre esta parte del bosque de este a oeste."
data "Camino norte. El camino norte de Westmorland se interna hacia el bosque, al norte (en tu estado no puedes ir), y a Westmorland, al sur."
data "Westmorland. La villa bulle de actividad con el mercado en el centro de la plaza, donde se encuentra el castillo."
defproc label_location_descriptions_end:enddef

rem Salidas de los escenarios
rem Location exits

rem  n,s,e,o,ar,ab
rem  n,s,e,w,d,u
data 0,2,0,0,0,0
data 1,0,0,3,0,0
data 0,0,2,4,0,0
data 5,0,3,9,0,0
data 0,4,0,6,0,0
data 0,0,5,7,0,0
data 0,8,6,0,0,0
data 7,10,0,0,0,0
data 0,0,4,0,0,0
data 8,0,0,11,0,0
data 0,0,10,0,0,0
data 0,0,0,13,0,0
data 0,0,12,14,0,0
data 0,15,13,0,0,0
data 14,17,16,0,0,0
data 0,0,0,15,0,0
data 15,20,18,0,0,0
data 0,0,19,17,0,0
data 0,0,0,18,0,0
data 17,22,25,0,0,0
data 0,27,23,20,0,0
data 0,24,27,22,0,0
data 0,25,0,21,0,0
data 22,0,26,0,0,0
data 22,28,23,21,0,0
data 26,0,20,27,0,0
data 27,0,0,25,0,0
data 26,0,0,0,0,0
data 0,0,0,28,0,30
data 0,0,31,0,29,0
data 0,0,0,30,0,0
data 0,33,0,31,0,0
data 32,0,34,0,0,0
data 35,0,0,33,0,0
data 40,34,0,36,0,36
data 0,0,35,37,35,0
data 0,0,36,38,0,0
data 0,0,37,39,0,0
data 0,0,38,0,0,0
data 0,35,41,0,0,0
data 0,0,0,40,0,0
data 41,43,0,0,0,0
data 42,0,0,0,0,0
data 43,0,0,45,0,0
data 0,47,44,46,0,0
data 0,0,45,0,0,0
data 45,0,0,0,0,0
data 0,0,47,49,0,0
data 0,0,48,50,0,0
data 0,51,49,0,0,0
data 50,0,0,0,0,0

rem Nombres
rem Nouns

rem datos: identificador de cosa, nombre
rem (para cada identificador de cosa, el último nombre listado será el principal)
rem data: thing id, noun
rem (for every thing id, the last noun listed will be the main one) 
defproc label_nouns_start:enddef
data ambrosio,"ambrosio"
data the_altar,"altar"
data the_cloak,"capa"
data the_door,"puerta"
data the_emerald,"joya"
data the_emerald,"esmeralda"
data the_fallen_away,"derrumbe"
data the_flags,"enseñas"
data the_flags,"pendones"
data the_flags,"banderas"
data the_flint,"pedernal"
data the_idol,"agujero"
data the_idol,"ojo"
data the_idol,"ídolo"
data the_key,"llave"
data the_lake,"agua"
data the_lake,"laguna"
data the_lake,"lago"
data the_lock,"cerrojo"
data the_lock,"cierre"
data the_lock,"candado"
data the_log,"leño"
data the_log,"madero"
data the_log,"tronco"
data the_man,"anciano"
data the_man,"jefe"
data the_man,"viejo"
data the_man,"hombre"
data the_piece,"pedazo"
data the_piece,"trozo"
data the_rags,"harapo"
data the_rocks,"rocas"
data the_snake,"culebra"
data the_snake,"ofidio"
data the_snake,"reptil"
data the_snake,"serpiente"
data the_stone,"piedra"
data the_sword,"arma"
data the_sword,"tizona"
data the_sword,"espada"
data the_thread,"hebra"
data the_thread,"hilo"
data the_torch,"antorcha"
data the_waterfall,"catarata"
data the_waterfall,"cascada"
defproc label_nouns_end:enddef

rem Cosas
rem Things

rem datos: identificador,escenario,tipo,descripción
rem data: id,location,type,description
defproc label_things_start:enddef
data the_altar,18,1
data "Justo en la mitad del puente, debe sostener algo importante."
data ambrosio,19,2
data "Ambrosio es un hombre de mediana edad, que te mira afable."
data the_torch,limbo,0
data "Está apagada."
data the_flags,28,1
data "Son las banderas britana y sajona. Dos dragones rampantes, rojo y blanco, enfrentados."
data the_cloak,ulfius,0
data "Tu capa de general, de fina lana tintada de negro."
data the_waterfall,38,1
data "No ves nada por la cortina de agua. El lago es muy poco profundo."
data the_fallen_away,9,1
data "Muchas, inalcanzables rocas, apiladas una sobre otra."
data the_emerald,39,0
data "Es preciosa."
data the_sword,ulfius,0
data "Legado de tu padre, fiel herramienta en mil batallas."
data the_rags,limbo,0
data "Un trozo un poco grande de capa."
data the_thread,limbo,0
data "Un hilo se ha desprendido al cortar la capa con la espada."
data the_man,28,1
data "Es el jefe de los refugiados."
data the_idol,41,1
data "El ídolo tiene dos agujeros por ojos."
data the_lake,44,1
data "La luz entra por un resquicio, y caprichosos reflejos te maravillan."
data the_key,46,1
data "Una llave grande, de hierro herrumboso."
data the_flint,limbo,0
data "Se trata de una dura y afilada piedra."
data the_stone,18,0
data "Recia y pesada, pero no muy grande, de forma piramidal."
data the_door,47,1
data "Muy recia y con un gran candado."
data the_rocks,31,1
data "Son muchas, aunque parecen ligeras y con huecos entre ellas."
data the_snake,43,1
data "Una serpiente bloquea el paso al sur, corriendo a su lado el agua."
data the_log,15,0
data "Es un tronco recio, pero de liviano peso."
data the_piece,limbo,0
data "Es un poco de lo que antes era tu capa."
data the_lock,47,1
data "Está cerrado. Es muy grande y parece resistente."
defproc label_things_end:enddef

rem Acciones
rem Actions

rem datos: identificador de acción, sintaxis de la acción 
rem data: action id,action syntax 
defproc label_actions_start:enddef
data to_break,object_needed
data to_drop,object_needed
data to_examine,no_object_needed
data to_finish,no_object_needed
data to_fling,object_needed
data to_go_down,no_object_needed
data to_go_east,no_object_needed
data to_go_north,no_object_needed
data to_go_south,no_object_needed
data to_go_up,no_object_needed
data to_go_west,no_object_needed
data to_help,no_object_needed
data to_insert,object_and_complement_needed
data to_look,no_object_needed
data to_open,object_needed
data to_swim,no_object_needed
data to_take,object_needed
data to_talk,object_needed
defproc label_actions_end:enddef

rem Verbos 
rem Verbs 

rem datos: identificador de acción, verbo o sinónimo, sintaxis de la acción (solo para el primer sinónimo)
rem data: action id,verb or synonym,action syntax (only for the first synonym)
defproc label_verbs_start:enddef
data to_break,"afila"
data to_break,"afilar"
data to_break,"ataca"
data to_break,"atacar"
data to_break,"corta"
data to_break,"cortar"
data to_break,"destroza"
data to_break,"destrozar"
data to_break,"empuja"
data to_break,"empujar"
data to_break,"golpea"
data to_break,"golpear"
data to_break,"mata"
data to_break,"matar"
data to_break,"recorta"
data to_break,"recortar"
data to_break,"rompe"
data to_break,"romper"
data to_break,"sacude"
data to_break,"sacudir"
data to_drop,"deja"
data to_drop,"dejar"
data to_drop,"desprenderse"
data to_drop,"despréndete"
data to_drop,"soltar"
data to_drop,"suelta"
data to_examine,"ex"
data to_examine,"examina"
data to_examine,"examinar"
data to_examine,"examinarte"
data to_examine,"examínate"
data to_examine,"i"
data to_finish,"acaba"
data to_finish,"acabar"
data to_finish,"fin"
data to_finish,"finaliza"
data to_finish,"finalizar"
data to_finish,"termina"
data to_finish,"terminar"
data to_fling,"arroja"
data to_fling,"arrojar"
data to_fling,"lanza"
data to_fling,"lanzar"
data to_fling,"tira"
data to_fling,"tirar"
data to_go_down,"abajo"
data to_go_down,"baja"
data to_go_down,"bajar"
data to_go_down,"descender"
data to_go_down,"desciende"
data to_go_east,"e"
data to_go_east,"este"
data to_go_north,"n"
data to_go_north,"norte"
data to_go_south,"s"
data to_go_south,"sur"
data to_go_up,"arriba"
data to_go_up,"ascender"
data to_go_up,"asciende"
data to_go_up,"sube"
data to_go_up,"subir"
data to_go_west,"o"
data to_go_west,"oeste"
data to_help,"auxilio"
data to_help,"ayuda"
data to_help,"ayudar"
data to_help,"ayúdame"
data to_help,"socorro"
data to_insert,"coloca"
data to_insert,"colocar"
data to_insert,"introduce"
data to_insert,"introducir"
data to_insert,"mete"
data to_insert,"meter"
data to_insert,"pon"
data to_insert,"poner"
data to_insert,"situar"
data to_insert,"sitúa"
data to_look,"m"
data to_look,"mira"
data to_look,"mirar"
data to_look,"ojea"
data to_look,"ojear"
data to_open,"abre"
data to_open,"abrir"
data to_swim,"bañar"
data to_swim,"bucea"
data to_swim,"bucear"
data to_swim,"báñarse"
data to_swim,"báñate"
data to_swim,"nada"
data to_swim,"nadar"
data to_swim,"zambullirse"
data to_swim,"zambúllete"
data to_take,"agarra"
data to_take,"agarrar"
data to_take,"coge"
data to_take,"coger"
data to_take,"toma"
data to_take,"tomar"
data to_talk,"charla"
data to_talk,"charlar"
data to_talk,"comenta"
data to_talk,"comentar"
data to_talk,"comentarle"
data to_talk,"coméntale"
data to_talk,"coméntalo"
data to_talk,"coméntaselo"
data to_talk,"conversa"
data to_talk,"conversar"
data to_talk,"decir"
data to_talk,"decirle"
data to_talk,"di"
data to_talk,"dile"
data to_talk,"dilo"
data to_talk,"díselo"
data to_talk,"habla"
data to_talk,"hablar"
data to_talk,"hablarle"
data to_talk,"platica"
data to_talk,"platicar"
data to_talk,"platicarle"
data to_talk,"platicarlo"
data to_talk,"platícale"
data to_talk,"platícalo"
data to_talk,"pregunta"
data to_talk,"preguntar"
data to_talk,"preguntarle"
data to_talk,"preguntarlo"
data to_talk,"preguntárselo"
data to_talk,"pregúntale"
defproc label_verbs_end:enddef

rem --------------------------------------------
rem Meta

deffn lines_between(procedure_1$,procedure_2$)

  loc line_step
  let line_step=10
  ret (lnum(procedure_2$)-lnum(procedure_1$))/line_step-1

enddef

defproc s

  save_o "ayc_rendered_bas"

enddef

defproc fatal_error(message$)

  ink #tw,red
  print #tw,"Fatal error:"!message$
  stop

enddef

defproc _debug(text$)

  print #tw,"DEBUG POINT:"&text$

enddef

